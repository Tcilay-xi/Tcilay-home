import { render } from 'ejs';
import { expand } from 'dotenv-expand';
import dotenv from 'dotenv';
import { join, dirname, resolve, basename } from 'pathe';
import fse from 'fs-extra';
import { createFilter } from '@rollup/pluginutils';
import { normalizePath } from 'vite';
import { parse } from 'node-html-parser';
import fg from 'fast-glob';
import consola from 'consola';
import { dim } from 'colorette';
import history from 'connect-history-api-fallback';
import { minify } from 'html-minifier-terser';

function loadEnv(mode, envDir, prefix = "") {
  if (mode === "local") {
    throw new Error(`"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.`);
  }
  const env = {};
  const envFiles = [
    `.env.${mode}.local`,
    `.env.${mode}`,
    `.env.local`,
    `.env`
  ];
  for (const file of envFiles) {
    const path = lookupFile(envDir, [file], true);
    if (path) {
      const parsed = dotenv.parse(fse.readFileSync(path), {
        debug: !!process.env.DEBUG || void 0
      });
      expand({
        parsed,
        ignoreProcessEnv: true
      });
      for (const [key, value] of Object.entries(parsed)) {
        if (key.startsWith(prefix) && env[key] === void 0) {
          env[key] = value;
        } else if (key === "NODE_ENV") {
          process.env.VITE_USER_NODE_ENV = value;
        }
      }
    }
  }
  return env;
}
function lookupFile(dir, formats, pathOnly = false) {
  for (const format of formats) {
    const fullPath = join(dir, format);
    if (fse.pathExistsSync(fullPath) && fse.statSync(fullPath).isFile()) {
      return pathOnly ? fullPath : fse.readFileSync(fullPath, "utf-8");
    }
  }
  const parentDir = dirname(dir);
  if (parentDir !== dir) {
    return lookupFile(parentDir, formats, pathOnly);
  }
}
function cleanUrl(url) {
  const queryRE = /\?.*$/s;
  const hashRE = /#.*$/s;
  return url.replace(hashRE, "").replace(queryRE, "");
}
async function isDirEmpty(dir) {
  return fse.readdir(dir).then((files) => {
    return files.length === 0;
  });
}

const htmlFilter = createFilter(["**/*.html"]);

const DEFAULT_TEMPLATE = "index.html";
const ignoreDirs = [".", "", "/"];
const bodyInjectRE = /<\/body>/;
function createPlugin(userOptions = {}) {
  const {
    entry,
    template = DEFAULT_TEMPLATE,
    pages = [],
    verbose = false
  } = userOptions;
  let viteConfig;
  let env = {};
  return {
    name: "vite:html",
    enforce: "pre",
    configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
      env = loadEnv(viteConfig.mode, viteConfig.root, "");
    },
    config(conf) {
      const input = createInput(userOptions, conf);
      if (input) {
        return {
          build: {
            rollupOptions: {
              input
            }
          }
        };
      }
    },
    configureServer(server) {
      server.middlewares.use(history({
        disableDotRule: void 0,
        htmlAcceptHeaders: ["text/html", "application/xhtml+xml"]
      }));
      server.middlewares.use(async (req, res, next) => {
        const url = cleanUrl(req.url || "");
        const base = viteConfig.base;
        const excludeBaseUrl = url.replace(base, "/");
        if (!htmlFilter(url) && excludeBaseUrl !== "/") {
          return next();
        }
        try {
          const htmlName = excludeBaseUrl === "/" ? DEFAULT_TEMPLATE : url.replace("/", "");
          const page = getPage(userOptions, htmlName, viteConfig);
          const { injectOptions = {} } = page;
          let html = await getHtmlInPages(page, viteConfig.root);
          html = await renderHtml(html, {
            injectOptions,
            viteConfig,
            env,
            entry: page.entry || entry,
            verbose
          });
          html = await server.transformIndexHtml?.(url, html, req.originalUrl);
          res.end(html);
        } catch (e) {
          consola.log(e);
        }
      });
    },
    transform(code, id) {
      if (viteConfig.command === "build" && htmlFilter(id)) {
        const htmlName = id.match("[^/]+(?!.*/)")?.[0] ?? DEFAULT_TEMPLATE;
        const page = getPage(userOptions, htmlName, viteConfig);
        const { injectOptions = {} } = page;
        return getHtmlInPages(page, viteConfig.root).then((html) => {
          return renderHtml(html, {
            injectOptions,
            viteConfig,
            env,
            entry: page.entry || entry,
            verbose
          }).then((resultHtml) => {
            return {
              code: resultHtml,
              map: null
            };
          });
        });
      }
      return {
        code,
        map: null
      };
    },
    async closeBundle() {
      const outputDirs = [];
      if (isMpa(viteConfig) || pages.length) {
        for (const page of pages) {
          const dir = dirname(page.template);
          if (!ignoreDirs.includes(dir)) {
            outputDirs.push(dir);
          }
        }
      } else {
        const dir = dirname(template);
        if (!ignoreDirs.includes(dir)) {
          outputDirs.push(dir);
        }
      }
      const cwd = resolve(viteConfig.root, viteConfig.build.outDir);
      const htmlFiles = await fg(outputDirs.map((dir) => `${dir}/*.html`), { cwd: resolve(cwd), absolute: true });
      await Promise.all(htmlFiles.map((file) => fse.move(file, resolve(cwd, basename(file)), { overwrite: true })));
      const htmlDirs = await fg(outputDirs.map((dir) => dir), { cwd: resolve(cwd), onlyDirectories: true, absolute: true });
      await Promise.all(htmlDirs.map(async (item) => {
        const isEmpty = await isDirEmpty(item);
        if (isEmpty) {
          return fse.remove(item);
        }
      }));
    }
  };
}
function createInput({ pages = [], template = DEFAULT_TEMPLATE }, viteConfig) {
  const input = {};
  if (isMpa(viteConfig) || pages?.length) {
    const templates = pages.map((page) => page.template);
    templates.forEach((temp) => {
      const file = basename(temp);
      const key = file.replace(/\.html/, "");
      input[key] = resolve(viteConfig.root, temp);
    });
    return input;
  } else {
    const dir = dirname(template);
    if (ignoreDirs.includes(dir)) {
      return void 0;
    } else {
      const file = basename(template);
      const key = file.replace(/\.html/, "");
      return {
        [key]: resolve(viteConfig.root, template)
      };
    }
  }
}
async function renderHtml(html, config) {
  const { injectOptions, viteConfig, env, entry, verbose } = config;
  const { data, ejsOptions } = injectOptions;
  const ejsData = {
    ...viteConfig?.env ?? {},
    ...viteConfig?.define ?? {},
    ...env || {},
    ...data
  };
  let result = await render(html, ejsData, ejsOptions);
  if (entry) {
    result = removeEntryScript(result, verbose);
    result = result.replace(bodyInjectRE, `<script type="module" src="${normalizePath(`/${entry}`)}"><\/script>
</body>`);
  }
  return result;
}
function getPage({ pages = [], entry, template = DEFAULT_TEMPLATE, inject = {} }, name, viteConfig) {
  let page;
  if (isMpa(viteConfig) || pages?.length) {
    page = getPageConfig(name, pages, DEFAULT_TEMPLATE);
  } else {
    page = createSpaPage(entry, template, inject);
  }
  return page;
}
function isMpa(viteConfig) {
  const input = viteConfig?.build?.rollupOptions?.input ?? void 0;
  return typeof input !== "string" && Object.keys(input || {}).length > 1;
}
function removeEntryScript(html, verbose = false) {
  if (!html) {
    return html;
  }
  const root = parse(html);
  const scriptNodes = root.querySelectorAll("script[type=module]") || [];
  const removedNode = [];
  scriptNodes.forEach((item) => {
    removedNode.push(item.toString());
    item.parentNode.removeChild(item);
  });
  verbose && removedNode.length && consola.warn(`vite-plugin-html: Since you have already configured entry, ${dim(removedNode.toString())} is deleted. You may also delete it from the index.html.
        `);
  return root.toString();
}
function createSpaPage(entry, template, inject = {}) {
  return {
    entry,
    filename: "index.html",
    template,
    injectOptions: inject
  };
}
function getPageConfig(htmlName, pages, defaultPage) {
  const defaultPageOption = {
    filename: defaultPage,
    template: `./${defaultPage}`
  };
  const page = pages.filter((page2) => page2.filename === htmlName)?.[0];
  return page ?? defaultPageOption ?? void 0;
}
function getHtmlInPages(page, root) {
  const htmlPath = getHtmlPath(page, root);
  return readHtml(htmlPath);
}
function getHtmlPath(page, root) {
  const { template } = page;
  const templatePath = template.startsWith(".") ? template : `./${template}`;
  return resolve(root, templatePath);
}
async function readHtml(path) {
  if (!fse.pathExistsSync(path)) {
    throw new Error(`html is not exist in ${path}`);
  }
  return await fse.readFile(path).then((buffer) => buffer.toString());
}

function getOptions(minify) {
  return {
    collapseWhitespace: minify,
    keepClosingSlash: minify,
    removeComments: minify,
    removeRedundantAttributes: minify,
    removeScriptTypeAttributes: minify,
    removeStyleLinkTypeAttributes: minify,
    useShortDoctype: minify,
    minifyCSS: minify
  };
}
async function minifyHtml(html, minify$1) {
  if (typeof minify$1 === "boolean" && !minify$1) {
    return html;
  }
  let minifyOptions = minify$1;
  if (typeof minify$1 === "boolean" && minify$1) {
    minifyOptions = getOptions(minify$1);
  }
  return await minify(html, minifyOptions);
}
function createMinifyHtmlPlugin({
  minify = true
} = {}) {
  return {
    name: "vite:minify-html",
    enforce: "post",
    async generateBundle(_, outBundle) {
      if (minify) {
        for (const bundle of Object.values(outBundle)) {
          if (bundle.type === "asset" && htmlFilter(bundle.fileName) && typeof bundle.source === "string") {
            bundle.source = await minifyHtml(bundle.source, minify);
          }
        }
      }
    }
  };
}

consola.wrapConsole();
function createHtmlPlugin(userOptions = {}) {
  return [createPlugin(userOptions), createMinifyHtmlPlugin(userOptions)];
}

export { createHtmlPlugin };
